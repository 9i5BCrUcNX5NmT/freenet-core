use std::fmt::Display;

use blake2::{Blake2s256, Digest};
use serde::{Deserialize, Serialize};
use serde_with::serde_as;

use crate::prelude::{ContractInstanceId, WasmLinearMem};

const APPLICATION_HASH_SIZE: usize = 32;
const COMPONENT_HASH_LENGTH: usize = 32;

#[serde_as]
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq)]
pub struct SecretsId {
    #[serde_as(as = "serde_with::Bytes")]
    key: Vec<u8>,
    #[serde_as(as = "[_; 32]")]
    hash: [u8; 32],
}

impl SecretsId {
    pub fn new(key: Vec<u8>) -> Self {
        let mut hasher = Blake2s256::new();
        hasher.update(&key);
        let hashed = hasher.finalize();
        let mut hash = [0; 32];
        hash.copy_from_slice(&hashed);
        Self { key, hash }
    }

    pub fn encode(&self) -> String {
        bs58::encode(self.hash)
            .with_alphabet(bs58::Alphabet::BITCOIN)
            .into_string()
    }
}

pub trait Component {
    /// Process inbound messages, producing zero or more outbound messages in response
    /// Note that all state for the component must be stored using the secret mechanism.
    fn process(&mut self, messages: Vec<InboundComponentMsg>) -> Vec<OutboundComponentMsg>;
}

#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct ComponentKey([u8; COMPONENT_HASH_LENGTH]);

impl ComponentKey {
    pub fn new(wasm_code: &[u8]) -> Self {
        let mut hasher = Blake2s256::new();
        hasher.update(&wasm_code);
        let hashed = hasher.finalize();
        let mut component_key = [0; COMPONENT_HASH_LENGTH];
        component_key.copy_from_slice(&hashed);
        Self(component_key)
    }

    pub fn encode(&self) -> String {
        bs58::encode(self.0)
            .with_alphabet(bs58::Alphabet::BITCOIN)
            .into_string()
    }
}

impl Display for ComponentKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.encode())
    }
}

#[derive(Serialize, Deserialize)]
pub struct ComponentContext(#[serde(skip)] Vec<u8>);

impl ComponentContext {
    pub const MAX_SIZE: usize = 4096 * 10 * 10;

    pub fn new(bytes: Vec<u8>) -> Self {
        assert!(bytes.len() < Self::MAX_SIZE);
        Self(bytes)
    }

    pub fn append(&mut self, bytes: &mut Vec<u8>) {
        assert!(self.0.len() + bytes.len() < Self::MAX_SIZE);
        self.0.append(bytes)
    }

    pub fn replace(&mut self, bytes: Vec<u8>) {
        assert!(bytes.len() < Self::MAX_SIZE);
        let _ = std::mem::replace(&mut self.0, bytes);
    }
}

#[serde_as]
#[derive(Serialize, Deserialize)]
pub struct ContractHash(#[serde_as(as = "[_; APPLICATION_HASH_SIZE]")] [u8; APPLICATION_HASH_SIZE]);

// todo: on the API on the node provide a call for requesting SECURE random bytes
// todo: on component creation, the key is generated by the code

#[derive(Serialize, Deserialize)]
pub enum InboundComponentMsg {
    GetSecretResponse(GetSecretResponse),
    ApplicationMessage(ApplicationMessage),
    UserResponse(UserInputResponse),
    // GetContractResponse {
    //     contract_id: ContractInstanceId,
    //     #[serde(borrow)]
    //     update_data: UpdateData<'static>,
    //     context: Context
    // },
}

#[derive(Serialize, Deserialize)]
pub struct GetSecretResponse {
    pub key: SecretsId,
    pub value: Option<Vec<u8>>,
    pub context: ComponentContext,
}

#[non_exhaustive]
#[derive(Serialize, Deserialize)]
pub struct ApplicationMessage {
    pub app: ContractInstanceId,
    pub payload: Vec<u8>,
    pub context: ComponentContext,
}

impl ApplicationMessage {
    pub fn new(app: ContractInstanceId, payload: Vec<u8>, context: ComponentContext) -> Self {
        Self {
            app,
            payload,
            context,
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct UserInputResponse {
    request_id: u32,
    response: ClientResponse,
    context: ComponentContext,
}

#[derive(Serialize, Deserialize)]
pub enum OutboundComponentMsg {
    // from the node
    GetSecretRequest(GetSecretRequest),
    SetSecretRequest(SetSecretRequest),
    // from the apps
    ApplicationMessage(ApplicationMessage),
    RequestUserInput(UserInputRequest),
    // GetContractRequest {
    //     mode: RelatedMode,
    //     contract_id: ContractInstanceId,
    // },
}

#[non_exhaustive]
#[derive(Serialize, Deserialize)]
pub struct GetSecretRequest {
    pub key: SecretsId,
    pub context: ComponentContext,
}

#[derive(Serialize, Deserialize)]
pub struct SetSecretRequest {
    pub key: SecretsId,
    /// Sets or unsets (if none) a value associated with the key.
    pub value: Option<Vec<u8>>,
}

#[serde_as]
#[derive(Serialize, Deserialize)]
pub struct NotificationMessage(#[serde_as(as = "serde_with::Bytes")] Vec<u8>);

#[serde_as]
#[derive(Serialize, Deserialize)]
pub struct ClientResponse(#[serde_as(as = "serde_with::Bytes")] Vec<u8>);

#[derive(Serialize, Deserialize)]
pub struct UserInputRequest {
    request_id: u32,
    /// An interpretable message by the notification system.
    message: NotificationMessage,
    /// If a response is required from the user they can be chosen from this list.
    responses: Vec<ClientResponse>,
    context: ComponentContext,
}

#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct ComponentInterfaceResult {
    ptr: i64,
    kind: i32,
    size: u32,
}

impl ComponentInterfaceResult {
    pub unsafe fn from_raw(ptr: i64, mem: &WasmLinearMem) -> Self {
        todo!()
    }
}

impl From<ComponentInterfaceResult> for OutboundComponentMsg {
    fn from(result: ComponentInterfaceResult) -> Self {
        todo!()
    }
}
