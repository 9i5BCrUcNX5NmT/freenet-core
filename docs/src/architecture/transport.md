# Freenet Transport Protocol

Freenet's Transport Protocol (FTS) is designed to provide a reliable, encrypted message-based transport system over
UDP.

## Establishing a connection between two peers

### Both peers behind NAT

This is from the perspective of Peer A, but the same steps are taken by Peer B as the protocol is symmetrical.

1. To establish a direct connection both peers must know the other peer's IP address, port, and public key.
2. Peer A randomly generates an [Aes128Gcm](https://docs.rs/aes-gcm/0.10.3/aes_gcm/type.Aes128Gcm.html) symmetric 
   key, the `outbound_symmetric_key`.
3. Peer A encrypts the `outbound_symmetric_key` with Peer B's public key, the `encrypted_symmetric_key` and
   send it to Peer B, this is the `outbound_hello_message`.
   1. Note that the `outbound_hello_message` is unique in that it is the only message type that isn't encrypted
      with the `outbound_symmetric_key`. 
4. At the same time Peer A listens for a `inbound_hello_message` from Peer B. When it receives this it 
   decrypts the `inbound_symmetric_key` using its private key and stores it in `UdpConnectionInfo`.
5. Peer A resends the `outbound_hello_message` every 200ms until it receives a `hello_ack` message from Peer B,
   until it reaches a timeout of 5 seconds, at which point the connection attempt has failed.
6. Peer A sends a `hello_ack` message to Peer B encrypted with the `outbound_symmetric_key`.
   1. Peer A checks future messages from peer B to see if they are identical to the `inbound_hello_message`, if
      it receives another one (perhaps because the `hello_ack` was lost) it sends another `hello_ack` message
      and otherwise disregards the message. 
7. When both peers have received a `hello_ack` message from the other peer they have established a connection.

### Peer A behind NAT, Peer B is a gateway

In this scenario only Peer A is attempting to initiate the connection, Peer B is a gateway and will listen for
any connections coming from any other peer. Peer A must know Peer B's IP address, port, and public key - but
Peer B is initially unaware of Peer A. Peer A knows that it's trying to connect to a gateway.

The key difference between this scenario and the previous one is that the same symmetric key is used both
for outbound and inbound, this key is chosen by Peer A.

1. Peer A randomly generates an AES128 symmetric key, which will serve as both the `outbound_symmetric_key`
   and `inbound_symmetric_key`.
2. Peer A creates and sends the `outbound_hello_message` to Peer B, which is the symmetric key encrypted with 
   Peer B's public key, this is resent every 200ms as in the previous scenario.
4. Peer B receives the `outbound_hello_message` and decrypts it with its private key, storing the symmetric key
   in `UdpConnectionInfo`, and transmits a `hello_ack` message to Peer A encrypted with the symmetric key.

## Keep-alive messages

Once a connection has been established, both peers send a `keep_alive` message every 30 seconds to the other
peer to ensure that the connection remains open. If a peer does not receive a `keep_alive` or other message from the
other peer within 120 seconds it will close the connection.

## Symmetric message schema

```rust
pub struct SymmetricMessage {
    /// A unique number generated by the sender of this message, used to detect and discard duplicate messages
    /// and to identify dropped messages. These should start at `0` and increment by `1` for each message sent,
    /// they should wrap around to `0` after reaching `u16::MAX`.
    pub message_id: u16,
    
    /// This is used to confirm receipt of messages, the sender will resend messages if not confirmed within 
    /// 2 seconds (`MESSAGE_CONFIRMATION_TIMEOUT`), or if a message id is confirmed that came after a message 
    /// that hasn't yet been confirmed (i.e. a message was dropped). Note: this could cause unnecessary
    /// retransmission of messages if received out-of-order, I'm assuming that this is rare enough that
    /// it's not worth the extra complexity to avoid it.
    pub confirm_receipt: Vec<u16>,
    
    pub payload: SymmetricMessagePayload,
}

pub enum SymmetricMessagePayload {
    AcknowledgeHello,
    
    /// This can be used to acknowledge the receipt of a message, or to request a resend of a message
    /// even if the peer doesn't otherwise have any messages to send
    NoOperation,
    
    KeepAlive,
    
    Disconnect,
    
    /// A message sent by the sender of this message
    ShortMessage { payload: Vec<u8>},
    
    LongMessageFragment {
        /// The total length of this message in bytes
        total_length: u64,
        
        /// The start byte of this fragment in the message
        start_index: u64,
        
        /// The payload of this fragment
        payload: Vec<u8>,
    },
}
``` 

## Handling dropped and out-of-order `SymmetricMessage`s

Every symmetric message has a `message_id` field, which is a unique number generated by the sender of the message.
In practice these will be generated sequentially starting at `0` and wrapping around to `u16::MAX`, this minimizes
the likelihood of duplicate message ids being used within a short timeframe.

When a peer receives a `SymmetricMessage` it checks if it has already received a message with the same `message_id`,
if so it discards the message but sends a `NoOperation` message back to the sender including it in confirm_receipt 
to re-confirm its receipt.

If a peer sends a message and doesn't receive an acknowledgement within 2 seconds (`MESSAGE_CONFIRMATION_TIMEOUT`) 
it will resend the message.

### Confirmation batching

To avoid having to send a receipt message for every message received, a peer can wait up to 500ms 
(`MAX_CONFIRMATION_DELAY`) before sending a receipt message. The hope is that this will allow multiple messages 
to be received and acknowledged with a single receipt message, potentially piggy-backing on a message that would 
have been sent anyway.

This can be achieved by maintaining a `receipt_queue`, perhaps a `VecDeque<(Instant, u16)>`, which stores the 
`message_id` that haven't yet been confirmed along with the time they were stored. If the receipt queue exceeds 
20 messages (`MAX_RECEIPT_QUEUE_SIZE`), then a receipt message will be sent immediately, this is to avoid the 
queue growing too large to fit in a single UDP packet.

It's obviously important that `MAX_CONFIRMATION_DELAY` is significantly less than `MESSAGE_CONFIRMATION_TIMEOUT`.

## Short and long message types

Short messages are messages that fit within a single UDP packet - maximum length 1kb, while long messages can have
unlimited length and are split into fragments.

One of the key goals of long messages is to allow a peer to start forwarding a long message to another peer before
it has received the entire message. This is essential for the efficient inserting and retrieving of large contract
states.

By convention the first fragment of a long message should explain what the message is, for example a response to
a request for a contract state, so the peer can decide how it will handle the remainder of the long message (eg. 
whether it will forward it to another peer).

## Rate limiting

FTS uses a simple rate limiting scheme to control bandwidth usage. We specify a maximum
upstream bandwidth in bytes per second - in practice this should be set higher than the peer's desired upstream
bandwidth usage as governed by the `topology` module, to allow for bursts of traffic - perhaps 50% higher.

While this should be hardwired initially, in future we can adjust it dynamically using an 
[isotonic regression](https://github.com/sanity/pav.rs) to determine the relationship between bandwidth usage and 
packet loss, and choosing the bandwidth limit accordingly.

The rate limiting is implemented by monitoring the number of bytes sent in the last 10 seconds 
(`BANDWIDTH_MESAUREMENT_WINDOW`), and if it exceeds the maximum bandwidth the peer will sleep for 10ms 
(`BANDWIDTH_CONTROL_SLEEP_DURATION`) and then check again, repeating until the bandwidth usage is below the limit.

In future we should consider a more sophisticated approach to determining the sleep time, however we should bear
in mind that sleeping for very short periods of time (eg. 1ms) is not very accurate on most operating systems.